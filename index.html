<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Crypto Options Arbitrage Scanner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the dark theme and specific elements */
        body {
            font-family: 'Sarabun', sans-serif;
            background-color: #111827; /* Dark background */
            color: #d1d5db; /* Light text */
        }
        .table-header {
            background-color: #374151; /* Darker gray for table header */
            color: #f9fafb; /* White text for header */
        }
        .positive-arbitrage {
            color: #4ade80; /* Green for positive arbitrage profit */
            font-weight: 700; /* Bold text */
        }
        .log-entry {
            border-left: 2px solid #4b5563; /* Gray border for log entries */
        }
        .log-success {
            border-left-color: #4ade80; /* Green border for success logs */
        }
        .log-warn {
            border-left-color: #facc15; /* Yellow border for warning/alert logs */
        }
        .tab-active {
            background-color: #4f46e5; /* Indigo for active tab */
            color: #fff; /* White text */
        }
        .tab-inactive {
            background-color: #374151; /* Dark gray for inactive tab */
            color: #d1d5db; /* Light text */
        }

        /* Keyframe animation for alert highlight */
        @keyframes pulse-bg {
            0%, 100% { background-color: #1e3a8a; } /* Dark blue */
            50% { background-color: #3b82f6; } /* Brighter blue */
        }
        .highlight-alert {
            animation: pulse-bg 1.5s infinite; /* Apply pulse animation */
        }

        /* Toast notification styles */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #2563eb; /* Blue background */
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Shadow effect */
            transform: translateX(120%); /* Start off-screen */
            transition: transform 0.5s ease-in-out; /* Smooth transition */
            z-index: 100; /* High z-index to be on top */
            opacity: 0; /* Initially hidden */
            pointer-events: none; /* Do not block interaction */
        }
        .toast.show {
            transform: translateX(0); /* Slide in */
            opacity: 1; /* Fade in */
            pointer-events: auto; /* Allow interaction */
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #1f2937;
            padding: 2rem;
            border-radius: 0.75rem;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #d1d5db;
            cursor: pointer;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-white">Dynamic Crypto Options Arbitrage Scanner</h1>
            <p class="text-indigo-400 mt-2">ค้นหา Box Spread และ Calendar Spread ที่มีกำไรสูงสุดอัตโนมัติ</p>
        </header>

        <!-- Controls & Settings Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div class="p-4 bg-gray-800 rounded-lg border border-gray-700 flex items-center justify-between">
                <div class="flex items-center space-x-2">
                    <!-- Connection status indicator -->
                    <div id="connection-status" class="w-4 h-4 rounded-full bg-yellow-500 animate-pulse"></div>
                    <span id="connection-text" class="text-yellow-400">กำลังเชื่อมต่อกับ Deribit...</span>
                </div>
                <!-- Last updated timestamp -->
                <div id="last-updated" class="text-sm text-gray-400">อัปเดตล่าสุด: -</div>
            </div>
            <div class="p-4 bg-gray-800 rounded-lg border border-gray-700">
                <h3 class="font-bold text-white mb-2">ตั้งค่าการแจ้งเตือนและการทำธุรกรรม</h3>
                <div class="flex flex-col space-y-3">
                    <div class="flex items-center space-x-3">
                        <label for="box-threshold" class="text-sm">แจ้งเตือนเมื่อกำไร > (USD):</label>
                        <!-- Input for arbitrage profit threshold -->
                        <input type="number" id="box-threshold" value="25" class="bg-gray-900 border border-gray-600 rounded-md p-1 w-24 text-center">
                        <!-- Mute/Unmute button for audio alerts -->
                        <button id="mute-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white text-xs font-bold py-1 px-3 rounded">ปิดเสียง</button>
                    </div>
                    <div class="flex items-center space-x-3">
                        <label for="transaction-fee" class="text-sm">ค่าธรรมเนียมการทำธุรกรรม (%):</label>
                        <!-- Input for transaction fee percentage -->
                        <input type="number" id="transaction-fee" value="0.03" step="0.01" class="bg-gray-900 border border-gray-600 rounded-md p-1 w-24 text-center">
                    </div>
                    <div class="flex items-center space-x-3 pt-2">
                        <!-- New: LLM-powered features -->
                        <button id="explain-arbitrage-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold py-2 px-4 rounded-md">✨ อธิบายกลยุทธ์</button>
                        <button id="risk-assessment-btn" class="bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold py-2 px-4 rounded-md">✨ ประเมินความเสี่ยง</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Arbitrage Type Tabs -->
        <div class="flex mb-4">
            <button id="tab-box-spread" class="tab-active py-2 px-4 rounded-l-lg font-semibold">Box Spread</button>
            <button id="tab-calendar-spread" class="tab-inactive py-2 px-4 rounded-r-lg font-semibold">Calendar Spread</button>
        </div>
        
        <!-- Box Spread Table -->
        <div id="box-spread-section" class="arb-section">
            <h2 class="text-xl font-bold text-white mb-3">Top 5 Box Spread Opportunities (BTC)</h2>
            <div class="overflow-x-auto bg-gray-800 rounded-lg shadow-md border border-gray-700">
                <table class="w-full text-sm text-left">
                    <thead class="table-header text-xs uppercase">
                        <tr>
                            <th class="px-4 py-3">Expiry</th>
                            <th class="px-4 py-3">Strike Range</th>
                            <th class="px-4 py-3">Net Premium (Executable Price USD)</th>
                            <th class="px-4 py-3">Theoretical Value (USD)</th>
                            <th class="px-4 py-3">Transaction Fees (USD)</th>
                            <th class="px-4 py-3">Arbitrage Profit (Net USD)</th>
                        </tr>
                    </thead>
                    <tbody id="box-table-body">
                        <tr id="box-loading-row"><td colspan="6" class="text-center p-8 text-gray-400">กำลังสแกนหา Options...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Calendar Spread Table -->
        <div id="calendar-spread-section" class="arb-section hidden">
            <h2 class="text-xl font-bold text-white mb-3">Top 5 Calendar Spread Opportunities (BTC)</h2>
            <div class="overflow-x-auto bg-gray-800 rounded-lg shadow-md border border-gray-700">
                <table class="w-full text-sm text-left">
                    <thead class="table-header text-xs uppercase">
                        <tr>
                            <th class="px-4 py-3">Type</th>
                            <th class="px-4 py-3">Strike</th>
                            <th class="px-4 py-3">Shorter Expiry</th>
                            <th class="px-4 py-3">Longer Expiry</th>
                            <th class="px-4 py-3">Premium Diff (Executable Price USD)</th>
                            <th class="px-4 py-3">Transaction Fees (USD)</th>
                            <th class="px-4 py-3">Arbitrage Profit (Net USD)</th>
                        </tr>
                    </thead>
                    <tbody id="calendar-table-body">
                        <tr id="calendar-loading-row"><td colspan="7" class="text-center p-8 text-gray-400">กำลังสแกนหา Options...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Execution Simulation Log Section -->
        <div class="mt-8">
            <h2 class="text-xl font-bold text-white mb-3">Execution & Alert Log</h2>
            <div id="log-container" class="bg-gray-900 rounded-lg p-4 h-48 overflow-y-auto border border-gray-700 space-y-3">
                <p class="text-gray-500">Log จะแสดงผลลัพธ์ที่นี่...</p>
            </div>
        </div>
    </div>
    
    <!-- Toast Notification Display -->
    <div id="toast-notification" class="toast"></div>

    <!-- LLM Response Modal -->
    <div id="llm-modal" class="modal">
        <div class="modal-content">
            <button id="modal-close-btn" class="modal-close-btn">&times;</button>
            <h3 id="modal-title" class="text-xl font-bold text-white mb-4"></h3>
            <div id="modal-body" class="text-gray-300">
                <div class="flex items-center justify-center p-4">
                    <div class="loading-spinner"></div>
                    <span class="ml-3 text-lg">กำลังสร้างคำตอบ...</span>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENTS ---
        const boxTableBody = document.getElementById('box-table-body');
        const calendarTableBody = document.getElementById('calendar-table-body');
        const logContainer = document.getElementById('log-container');
        const connStatus = document.getElementById('connection-status');
        const connText = document.getElementById('connection-text');
        const lastUpdatedEl = document.getElementById('last-updated');
        const boxThresholdInput = document.getElementById('box-threshold');
        const toastEl = document.getElementById('toast-notification');
        const muteBtn = document.getElementById('mute-btn');
        const boxLoadingRow = document.getElementById('box-loading-row');
        const calendarLoadingRow = document.getElementById('calendar-loading-row');
        const transactionFeeInput = document.getElementById('transaction-fee');

        // LLM-related DOM elements
        const explainArbitrageBtn = document.getElementById('explain-arbitrage-btn');
        const riskAssessmentBtn = document.getElementById('risk-assessment-btn');
        const llmModal = document.getElementById('llm-modal');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');

        // Arbitrage Type Tabs
        const tabBoxSpread = document.getElementById('tab-box-spread');
        const tabCalendarSpread = document.getElementById('tab-calendar-spread');
        const boxSpreadSection = document.getElementById('box-spread-section');
        const calendarSpreadSection = document.getElementById('calendar-spread-section');

        // --- STATE VARIABLES ---
        let ws = null; // WebSocket instance
        let audioCtx = null; // AudioContext for sound alerts
        let isMuted = false; // Mute state for audio alerts
        // Stores real-time bid/ask/mark for subscribed instruments (key: instrument_name, value: ticker data)
        let instrumentData = {}; 
        let potentialBoxSpreads = []; // Stores all possible box spread combinations
        let potentialCalendarSpreads = []; // Stores all possible calendar spread combinations
        let calculatedBoxSpreadsData = []; // Stores calculated box spreads for sorting and LLM context
        let calculatedCalendarSpreadsData = []; // Stores calculated calendar spreads for sorting and LLM context
        let alertedOpportunities = new Set(); // Stores IDs of opportunities that have triggered an alert
        let instrumentScanComplete = false; // Flag to indicate if initial instrument scan is done
        let currentArbitrageType = 'box'; // 'box' or 'calendar' - default to box spread

        let btcUsdPrice = 1; // Default BTC-USD price, will be updated by ticker data

        const RECONNECT_INTERVAL = 5000; // Time in ms to wait before attempting to reconnect WebSocket

        // --- AUDIO & VISUAL ALERTS ---
        /**
         * Initializes the Web Audio API context.
         * This needs to be called after a user gesture (e.g., a click)
         * to avoid browser autoplay policy restrictions.
         */
        function setupAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                addLog('Web Audio API พร้อมใช้งานสำหรับการแจ้งเตือน', 'info');
            } catch (e) {
                console.warn('Web Audio API is not supported in this browser.', e);
                addLog('ไม่รองรับ Web Audio API ในเบราว์เซอร์นี้. การแจ้งเตือนด้วยเสียงจะถูกปิดใช้งาน', 'warn');
            }
        }

        /**
         * Plays a short, softer triangle wave sound alert.
         */
        function playAlertSound() {
            if (!audioCtx || isMuted) return; // Don't play if audio context not ready or muted

            // Ensure audio context is not suspended
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'triangle'; // Changed to triangle for a softer sound
            oscillator.frequency.setValueAtTime(660, audioCtx.currentTime); // Lowered frequency for a mellower tone (was 880)
            gainNode.gain.setValueAtTime(0.01, audioCtx.currentTime); // Start quietly
            gainNode.gain.exponentialRampToValueAtTime(0.3, audioCtx.currentTime + 0.1); // Ramp up to 0.3 volume
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6); // Fade out over 0.6 seconds

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.6); // Stop after 0.6 seconds
        }

        /**
         * Displays a temporary toast notification at the bottom right.
         * @param {string} message - The message to display in the toast.
         */
        function showToast(message) {
            toastEl.textContent = message;
            toastEl.classList.add('show'); // Add 'show' class to trigger CSS transition
            setTimeout(() => {
                toastEl.classList.remove('show'); // Remove 'show' class to hide after delay
            }, 4000); // Display for 4 seconds
        }

        // Mute/Unmute button functionality
        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted; // Toggle mute state
            // Update button text and style based on mute state
            muteBtn.textContent = isMuted ? 'เปิดเสียง' : 'ปิดเสียง';
            muteBtn.classList.toggle('bg-yellow-600', !isMuted); // Yellow when unmuted
            muteBtn.classList.toggle('hover:bg-yellow-700', !isMuted);
            muteBtn.classList.toggle('bg-green-600', isMuted); // Green when muted
            muteBtn.classList.toggle('hover:bg-green-700', isMuted);
            addLog(`การแจ้งเตือนด้วยเสียงถูก ${isMuted ? 'ปิดเสียง' : 'เปิดเสียง'}`, 'info');
        });

        // Event listener to setup audio context on first user interaction
        document.body.addEventListener('click', () => {
            if (!audioCtx) setupAudio(); // Initialize audio context only once on user interaction
        }, { once: true });

        // --- LOGGING ---
        /**
         * Adds a new entry to the log container.
         * @param {string} message - The message to log.
         * @param {string} type - Type of log ('info', 'success', 'warn'). Affects styling.
         */
        function addLog(message, type = 'info') {
            // Remove initial placeholder message if present
            if (logContainer.querySelector('p.text-gray-500')) {
                logContainer.innerHTML = '';
            }
            const logEntry = document.createElement('div');
            // Apply Tailwind classes for styling based on log type
            logEntry.className = `log-entry p-2 text-sm rounded-md ${type === 'success' ? 'log-success bg-green-900/50' : type === 'warn' ? 'log-warn bg-yellow-900/50' : 'bg-gray-700/50'}`;
            logEntry.innerHTML = `<span class="font-mono text-gray-400">[${new Date().toLocaleTimeString()}]</span> ${message}`;
            logContainer.prepend(logEntry); // Add new log entry to the top
            // Limit log entries to 50 to prevent excessive DOM elements
            if (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // --- LOCAL STORAGE FOR THRESHOLD & FEES ---
        /**
         * Loads settings from local storage or uses defaults.
         */
        function loadSettings() {
            const storedThreshold = localStorage.getItem('boxArbitrageThreshold');
            if (storedThreshold !== null) {
                boxThresholdInput.value = storedThreshold;
                addLog(`โหลดค่าเกณฑ์การแจ้งเตือนจาก Local Storage: $${storedThreshold}`, 'info');
            }

            const storedFee = localStorage.getItem('boxArbitrageFee');
            if (storedFee !== null) {
                transactionFeeInput.value = storedFee;
                addLog(`โหลดค่าธรรมเนียมการทำธุรกรรมจาก Local Storage: ${storedFee}%`, 'info');
            }

            const storedArbType = localStorage.getItem('currentArbitrageType');
            if (storedArbType) {
                currentArbitrageType = storedArbType;
                // Set active tab based on loaded type
                if (currentArbitrageType === 'box') {
                    showBoxSpreadSection();
                } else {
                    showCalendarSpreadSection();
                }
            } else {
                // Default to box spread if no setting found
                showBoxSpreadSection();
            }
        }

        /**
         * Saves the current settings to local storage.
         */
        function saveSettings() {
            localStorage.setItem('boxArbitrageThreshold', boxThresholdInput.value);
            localStorage.setItem('boxArbitrageFee', transactionFeeInput.value);
            localStorage.setItem('currentArbitrageType', currentArbitrageType);
            addLog(`บันทึกการตั้งค่าทั้งหมดแล้ว`, 'info');
        }

        // Add event listeners to save settings on input change
        boxThresholdInput.addEventListener('change', saveSettings);
        transactionFeeInput.addEventListener('change', saveSettings);

        // --- ARBITRAGE TYPE TAB SWITCHING ---
        function showBoxSpreadSection() {
            boxSpreadSection.classList.remove('hidden');
            calendarSpreadSection.classList.add('hidden');
            tabBoxSpread.classList.add('tab-active');
            tabBoxSpread.classList.remove('tab-inactive');
            tabCalendarSpread.classList.remove('tab-active');
            tabCalendarSpread.classList.add('tab-inactive');
            currentArbitrageType = 'box';
            saveSettings(); // Save current tab preference
            updateAndRenderOpportunities(); // Re-render for the active tab
        }

        function showCalendarSpreadSection() {
            boxSpreadSection.classList.add('hidden');
            calendarSpreadSection.classList.remove('hidden');
            tabCalendarSpread.classList.add('tab-active');
            tabCalendarSpread.classList.remove('tab-inactive');
            tabBoxSpread.classList.remove('tab-active');
            tabBoxSpread.classList.add('tab-inactive');
            currentArbitrageType = 'calendar';
            saveSettings(); // Save current tab preference
            updateAndRenderOpportunities(); // Re-render for the active tab
        }

        tabBoxSpread.addEventListener('click', showBoxSpreadSection);
        tabCalendarSpread.addEventListener('click', showCalendarSpreadSection);


        // --- DYNAMIC INSTRUMENT DISCOVERY & ARBITRAGE CALCULATION ---
        // Global map to store options structured for Calendar Spreads: strike -> expiry -> type (C/P) -> instrument_name
        let calendarOptionsMap = {};
        // Global map to store options structured for Box Spreads: expiry -> strike -> type (C/P) -> instrument_name
        let boxOptionsMap = {};

        /**
         * Processes the list of instruments received from Deribit,
         * filters for BTC options, and populates both boxOptionsMap and calendarOptionsMap.
         * @param {Array<Object>} instruments - Array of instrument objects from Deribit API.
         */
        function processInstruments(instruments) {
            addLog('ประมวลผล Options ที่ได้รับจาก Deribit...', 'info');
            
            boxOptionsMap = {}; // Reset for Box Spreads
            calendarOptionsMap = {}; // Reset for Calendar Spreads

            instruments
                .filter(inst => inst.instrument_name.startsWith('BTC-') && inst.kind === 'option' && !inst.expired)
                .forEach(inst => {
                    const parts = inst.instrument_name.split('-');
                    const expiry = parts[1]; // e.g., '29JUN25'
                    const strike = parseInt(parts[2]); // e.g., 70000
                    const type = parts[3]; // 'C' for Call, 'P' for Put

                    // Populate boxOptionsMap (expiry -> strike -> type)
                    if (!boxOptionsMap[expiry]) {
                        boxOptionsMap[expiry] = {};
                    }
                    if (!boxOptionsMap[expiry][strike]) {
                        boxOptionsMap[expiry][strike] = {};
                    }
                    boxOptionsMap[expiry][strike][type] = inst.instrument_name;

                    // Populate calendarOptionsMap (strike -> expiry -> type)
                    if (!calendarOptionsMap[strike]) {
                        calendarOptionsMap[strike] = {};
                    }
                    if (!calendarOptionsMap[strike][expiry]) {
                        calendarOptionsMap[strike][expiry] = {};
                    }
                    calendarOptionsMap[strike][expiry][type] = inst.instrument_name;
                });
            
            createPotentialBoxSpreads();
            createPotentialCalendarSpreads();

            addLog(`สร้าง Box Spread ที่เป็นไปได้ทั้งหมด ${potentialBoxSpreads.length} ชุดสำหรับ BTC`, 'success');
            addLog(`สร้าง Calendar Spread ที่เป็นไปได้ทั้งหมด ${potentialCalendarSpreads.length} ชุดสำหรับ BTC`, 'success');
            
            instrumentScanComplete = true; // Mark initial scan as complete

            // 3. Subscribe to real-time tickers for all identified legs from both strategies
            const allBoxLegs = potentialBoxSpreads.flatMap(box => box.legs);
            const allCalendarLegs = potentialCalendarSpreads.flatMap(cal => cal.legs);
            const allUniqueLegs = new Set([...allBoxLegs, ...allCalendarLegs]); // Combine and get unique

            addLog(`กำลังติดตามราคา ${allUniqueLegs.size} instruments...`, 'info');
            
            // Subscribe in batches to avoid large single WebSocket messages
            const channels = Array.from(allUniqueLegs).map(leg => `ticker.${leg}.100ms`); // Create ticker channel string
            const batchSize = 100; // Max instruments per subscribe request
            for (let i = 0; i < channels.length; i += batchSize) {
                const batch = channels.slice(i, i + batchSize);
                ws.send(JSON.stringify({
                    "jsonrpc": "2.0",
                    "method": "public/subscribe",
                    "id": `sub-${i / batchSize}`, // Unique ID for each subscription batch
                    "params": { "channels": batch }
                }));
            }
        }

        /**
         * Creates all potential Box Spread combinations from `boxOptionsMap`.
         */
        function createPotentialBoxSpreads() {
            potentialBoxSpreads = [];
            for (const expiry in boxOptionsMap) {
                const strikes = Object.keys(boxOptionsMap[expiry]).map(Number).sort((a, b) => a - b);
                for (let i = 0; i < strikes.length; i++) {
                    for (let j = i + 1; j < strikes.length; j++) {
                        const k1 = strikes[i]; // Lower strike
                        const k2 = strikes[j]; // Higher strike
                        
                        const leg1 = boxOptionsMap[expiry][k1]?.C; // Buy Call K1
                        const leg2 = boxOptionsMap[expiry][k1]?.P; // Sell Put K1
                        const leg3 = boxOptionsMap[expiry][k2]?.C; // Sell Call K2
                        const leg4 = boxOptionsMap[expiry][k2]?.P; // Buy Put K2
                        
                        if (leg1 && leg2 && leg3 && leg4) {
                            potentialBoxSpreads.push({
                                id: `BOX-${expiry}-${k1}-${k2}`,
                                expiry: expiry,
                                k1: k1,
                                k2: k2,
                                legs: [leg1, leg2, leg3, leg4]
                            });
                        }
                    }
                }
            }
        }

        /**
         * Creates all potential Calendar Spread combinations from `calendarOptionsMap`.
         */
        function createPotentialCalendarSpreads() {
            potentialCalendarSpreads = [];
            for (const strike in calendarOptionsMap) {
                const expiries = Object.keys(calendarOptionsMap[strike]).sort(); // Sort expiries to ensure short before long
                for (let i = 0; i < expiries.length; i++) {
                    for (let j = i + 1; j < expiries.length; j++) {
                        const shorterExpiry = expiries[i];
                        const longerExpiry = expiries[j];

                        // Check for Call Calendar Spread (Sell Shorter Call, Buy Longer Call)
                        const shorterCall = calendarOptionsMap[strike][shorterExpiry]?.C;
                        const longerCall = calendarOptionsMap[strike][longerExpiry]?.C;
                        if (shorterCall && longerCall) {
                            potentialCalendarSpreads.push({
                                id: `CAL-${strike}-C-${shorterExpiry}-${longerExpiry}`,
                                type: 'CALL', // Type of option (Call/Put)
                                strike: parseInt(strike),
                                shorterExpiry: shorterExpiry,
                                longerExpiry: longerExpiry,
                                legs: [shorterCall, longerCall] // [Shorter Option, Longer Option]
                            });
                        }

                        // Check for Put Calendar Spread (Sell Shorter Put, Buy Longer Put)
                        const shorterPut = calendarOptionsMap[strike][shorterExpiry]?.P;
                        const longerPut = calendarOptionsMap[strike][longerExpiry]?.P;
                        if (shorterPut && longerPut) {
                            potentialCalendarSpreads.push({
                                id: `CAL-${strike}-P-${shorterExpiry}-${longerExpiry}`,
                                type: 'PUT', // Type of option (Call/Put)
                                strike: parseInt(strike),
                                shorterExpiry: shorterExpiry,
                                longerExpiry: longerExpiry,
                                legs: [shorterPut, longerPut] // [Shorter Option, Longer Option]
                            });
                        }
                    }
                }
            }
        }
        
        /**
         * Calculates and renders opportunities based on the current arbitrage type.
         */
        function updateAndRenderOpportunities() {
            if (!instrumentScanComplete) return;

            const threshold = parseFloat(boxThresholdInput.value) || 0;
            const transactionFeeRate = parseFloat(transactionFeeInput.value) / 100 || 0;
            
            // Create a copy of alerted opportunities to track which ones become unprofitable
            const previouslyAlerted = new Set(alertedOpportunities);
            alertedOpportunities.clear(); // Clear for current update cycle, re-add if still profitable

            if (currentArbitrageType === 'box') {
                calculatedBoxSpreadsData = [];
                potentialBoxSpreads.forEach(box => {
                    const legData = box.legs.map(leg => instrumentData[leg]);
                    // Ensure all legs have bid_price and ask_price for calculation
                    if (legData.some(d => !d || d.bid_price === undefined || d.ask_price === undefined)) {
                        return;
                    }

                    // For Box Spread:
                    // Leg 0: Buy Call K1 - BUY at ASK
                    // Leg 1: Sell Put K1 - SELL at BID
                    // Leg 2: Sell Call K2 - SELL at BID
                    // Leg 3: Buy Put K2 - BUY at ASK

                    const leg0CostUSD = legData[0].ask_price * btcUsdPrice; // Buy Call K1
                    const leg1RevenueUSD = legData[1].bid_price * btcUsdPrice; // Sell Put K1
                    const leg2RevenueUSD = legData[2].bid_price * btcUsdPrice; // Sell Call K2
                    const leg3CostUSD = legData[3].ask_price * btcUsdPrice; // Buy Put K2

                    // Net Premium (cash flow at time 0) = (Cost of Buy Call K1 + Cost of Buy Put K2) - (Revenue from Sell Put K1 + Revenue from Sell Call K2)
                    const netPremiumUSD = (leg0CostUSD + leg3CostUSD) - (leg1RevenueUSD + leg2RevenueUSD);

                    // Theoretical Value (Profit at expiry) for a Box Spread is always K2 - K1
                    const theoreticalValueUSD = box.k2 - box.k1;

                    // Transaction Fees: Sum of absolute values of premiums of all legs (as they are all traded), multiplied by fee rate
                    const totalPremiumsSum = leg0CostUSD + leg1RevenueUSD + leg2RevenueUSD + leg3CostUSD; // Sum of prices used for each leg
                    const transactionFeesUSD = totalPremiumsSum * transactionFeeRate;

                    // Arbitrage Profit: Theoretical Value - Net Premium (cost) - Transaction Fees
                    const arbitrageProfitUSD = theoreticalValueUSD - netPremiumUSD - transactionFeesUSD;

                    calculatedBoxSpreadsData.push({
                        id: box.id,
                        expiry: box.expiry,
                        k1: box.k1,
                        k2: box.k2,
                        netPremium: netPremiumUSD,
                        theoreticalValue: theoreticalValueUSD,
                        transactionFees: transactionFeesUSD,
                        arbitrageProfit: arbitrageProfitUSD,
                        legs: box.legs
                    });
                });

                // Sort by arbitrage profit in descending order
                calculatedBoxSpreadsData.sort((a, b) => b.arbitrageProfit - a.arbitrageProfit);
                renderBoxSpreadTable(calculatedBoxSpreadsData.slice(0, 5), threshold);

                // Check and alert for new profitable opportunities
                calculatedBoxSpreadsData.forEach(spread => {
                    if (spread.arbitrageProfit > threshold) {
                        const alertId = spread.id;
                        if (!previouslyAlerted.has(alertId)) {
                            playAlertSound();
                            showToast(`🚨 Box Spread Arbitrage Opportunity: $${spread.arbitrageProfit.toFixed(2)} for ${spread.expiry} ${spread.k1}-${spread.k2}K!`);
                            addLog(`🚨 พบโอกาส Arbitrage Box Spread ที่มีกำไร: $${spread.arbitrageProfit.toFixed(2)} สำหรับ ${spread.expiry} ${spread.k1}-${spread.k2}K`, 'warn');
                        }
                        alertedOpportunities.add(alertId); // Mark as alerted for this cycle
                    }
                });

            } else if (currentArbitrageType === 'calendar') {
                calculatedCalendarSpreadsData = [];
                potentialCalendarSpreads.forEach(calendar => {
                    const shorterLegData = instrumentData[calendar.legs[0]];
                    const longerLegData = instrumentData[calendar.legs[1]];

                    // Ensure both legs have bid_price and ask_price for calculation
                    if (!shorterLegData || shorterLegData.bid_price === undefined || shorterLegData.ask_price === undefined || 
                        !longerLegData || longerLegData.bid_price === undefined || longerLegData.ask_price === undefined) {
                        return;
                    }

                    // For Calendar Spread: Sell Shorter Expiry, Buy Longer Expiry (same strike, same type)
                    // Shorter Leg (Sell) - SELL at BID
                    // Longer Leg (Buy) - BUY at ASK

                    const shorterLegRevenueUSD = shorterLegData.bid_price * btcUsdPrice; // Sell Shorter
                    const longerLegCostUSD = longerLegData.ask_price * btcUsdPrice; // Buy Longer

                    // Premium Difference (Net Credit/Debit): Sell Shorter, Buy Longer
                    const premiumDiffUSD = shorterLegRevenueUSD - longerLegCostUSD;

                    // Transaction Fees: Sum of absolute values of premiums of both legs, multiplied by fee rate
                    const totalPremiumsSum = shorterLegRevenueUSD + longerLegCostUSD; // Sum of prices used for each leg
                    const transactionFeesUSD = totalPremiumsSum * transactionFeeRate;

                    // Arbitrage Profit (Net Credit after fees)
                    const arbitrageProfitUSD = premiumDiffUSD - transactionFeesUSD;

                    calculatedCalendarSpreadsData.push({
                        id: calendar.id,
                        type: calendar.type,
                        strike: calendar.strike,
                        shorterExpiry: calendar.shorterExpiry,
                        longerExpiry: calendar.longerExpiry,
                        premiumDiff: premiumDiffUSD,
                        transactionFees: transactionFeesUSD,
                        arbitrageProfit: arbitrageProfitUSD, // This represents the net credit
                        legs: calendar.legs
                    });
                });

                // Sort by arbitrage profit (net credit) in descending order
                calculatedCalendarSpreadsData.sort((a, b) => b.arbitrageProfit - a.arbitrageProfit);
                renderCalendarSpreadTable(calculatedCalendarSpreadsData.slice(0, 5), threshold);

                // Check and alert for new profitable opportunities
                calculatedCalendarSpreadsData.forEach(spread => {
                    // For calendar spreads, a positive arbitrageProfit means a net credit.
                    // We alert if this net credit exceeds the threshold.
                    if (spread.arbitrageProfit > threshold) {
                        const alertId = spread.id;
                        if (!previouslyAlerted.has(alertId)) {
                            playAlertSound();
                            showToast(`🚨 Calendar Spread Arbitrage Opportunity: $${spread.arbitrageProfit.toFixed(2)} for ${spread.strike}K ${spread.type} (${spread.shorterExpiry} / ${spread.longerExpiry})!`);
                            addLog(`🚨 พบโอกาส Arbitrage Calendar Spread ที่มีกำไร: $${spread.arbitrageProfit.toFixed(2)} สำหรับ ${spread.strike}K ${spread.type} (${spread.shorterExpiry} / ${spread.longerExpiry})`, 'warn');
                        }
                        alertedOpportunities.add(alertId); // Mark as alerted for this cycle
                    }
                });
            }

            // Clean up old alerts (opportunities that were profitable but are no longer)
            previouslyAlerted.forEach(alertId => {
                const foundInCurrent = (currentArbitrageType === 'box' ? calculatedBoxSpreadsData : calculatedCalendarSpreadsData).some(s => s.id === alertId && s.arbitrageProfit > threshold);
                if (!foundInCurrent) {
                    addLog(`โอกาส Arbitrage '${alertId}' ไม่เป็นที่น่าพอใจแล้ว`, 'info');
                }
            });
        }


        /**
         * Renders the top 5 Box Spread opportunities in the table.
         * @param {Array<Object>} spreads - Array of calculated box spread opportunities.
         * @param {number} threshold - The profit threshold for highlighting.
         */
        function renderBoxSpreadTable(spreads, threshold) {
            boxTableBody.innerHTML = ''; // Clear existing rows
            if (spreads.length === 0) {
                boxTableBody.innerHTML = `<tr><td colspan="6" class="text-center p-8 text-gray-400">ไม่พบโอกาส Box Spread ที่เป็นไปได้</td></tr>`;
                return;
            }

            spreads.forEach(spread => {
                const row = document.createElement('tr');
                row.className = `border-b border-gray-700 hover:bg-gray-700/50 ${spread.arbitrageProfit > threshold ? 'highlight-alert' : ''}`;
                row.innerHTML = `
                    <td class="px-4 py-3">${spread.expiry}</td>
                    <td class="px-4 py-3">${spread.k1} - ${spread.k2}</td>
                    <td class="px-4 py-3">${spread.netPremium.toFixed(2)} USD</td>
                    <td class="px-4 py-3">${spread.theoreticalValue.toFixed(2)} USD</td>
                    <td class="px-4 py-3">${spread.transactionFees.toFixed(2)} USD</td>
                    <td class="px-4 py-3 ${spread.arbitrageProfit > 0 ? 'positive-arbitrage' : 'text-red-400'}">${spread.arbitrageProfit.toFixed(2)} USD</td>
                `;
                boxTableBody.appendChild(row);
            });
        }

        /**
         * Renders the top 5 Calendar Spread opportunities in the table.
         * @param {Array<Object>} spreads - Array of calculated calendar spread opportunities.
         * @param {number} threshold - The profit threshold for highlighting.
         */
        function renderCalendarSpreadTable(spreads, threshold) {
            calendarTableBody.innerHTML = ''; // Clear existing rows
            if (spreads.length === 0) {
                calendarTableBody.innerHTML = `<tr><td colspan="7" class="text-center p-8 text-gray-400">ไม่พบโอกาส Calendar Spread ที่เป็นไปได้</td></tr>`;
                return;
            }

            spreads.forEach(spread => {
                const row = document.createElement('tr');
                row.className = `border-b border-gray-700 hover:bg-gray-700/50 ${spread.arbitrageProfit > threshold ? 'highlight-alert' : ''}`;
                row.innerHTML = `
                    <td class="px-4 py-3">${spread.type}</td>
                    <td class="px-4 py-3">${spread.strike}</td>
                    <td class="px-4 py-3">${spread.shorterExpiry}</td>
                    <td class="px-4 py-3">${spread.longerExpiry}</td>
                    <td class="px-4 py-3">${spread.premiumDiff.toFixed(2)} USD</td>
                    <td class="px-4 py-3">${spread.transactionFees.toFixed(2)} USD</td>
                    <td class="px-4 py-3 ${spread.arbitrageProfit > 0 ? 'positive-arbitrage' : 'text-red-400'}">${spread.arbitrageProfit.toFixed(2)} USD</td>
                `;
                calendarTableBody.appendChild(row);
            });
        }


        // --- WEBSOCKET CONNECTION TO DERIBIT ---
        /**
         * Establishes a WebSocket connection to Deribit.
         * Handles connection, disconnection, and message parsing.
         */
        function connectWebSocket() {
            if (ws) {
                ws.close();
            }
            // Using Deribit testnet for demonstration. For production, use wss://www.deribit.com/ws/api/v2
            ws = new WebSocket('wss://test.deribit.com/ws/api/v2'); 

            ws.onopen = () => {
                connStatus.classList.remove('bg-yellow-500', 'bg-red-500');
                connStatus.classList.add('bg-green-500');
                connStatus.classList.remove('animate-pulse'); // Stop pulsing when connected
                connText.textContent = 'เชื่อมต่อสำเร็จกับ Deribit';
                connText.classList.remove('text-yellow-400', 'text-red-400');
                connText.classList.add('text-green-400');
                addLog('เชื่อมต่อ WebSocket กับ Deribit สำเร็จ', 'success');

                // 1. Get current BTC-USD price (important for converting option premiums)
                ws.send(JSON.stringify({
                    "jsonrpc": "2.0",
                    "method": "public/get_index_price",
                    "id": 1,
                    "params": {
                        "index_name": "BTC_USD"
                    }
                }));

                // 2. Get all instruments (BTC options)
                ws.send(JSON.stringify({
                    "jsonrpc": "2.0",
                    "method": "public/get_instruments",
                    "id": 2,
                    "params": {
                        "currency": "BTC",
                        "kind": "option",
                        "expired": false
                    }
                }));
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                // Always update the "Last Updated" timestamp when any ticker data is received
                if (data.params && data.params.channel.startsWith('ticker.')) {
                    handleTickerUpdate(data.params.data);
                    lastUpdatedEl.textContent = `อัปเดตล่าสุด: ${new Date().toLocaleTimeString()}`; // Update timestamp here
                } else if (data.id === 1 && data.result) {
                    btcUsdPrice = data.result.index_price;
                    addLog(`ราคา BTC-USD อัปเดต: ${btcUsdPrice.toFixed(2)} USD`, 'info');
                } else if (data.id === 2 && data.result) {
                    processInstruments(data.result);
                } else if (data.method === 'subscription') {
                    // This is where real-time ticker data comes in after subscription
                    handleTickerUpdate(data.params.data);
                    lastUpdatedEl.textContent = `อัปเดตล่าสุด: ${new Date().toLocaleTimeString()}`; // Update timestamp for subscription messages too
                } else {
                    // console.log("Received:", data); // Log other messages for debugging
                }
            };

            ws.onclose = () => {
                connStatus.classList.remove('bg-green-500', 'bg-yellow-500');
                connStatus.classList.add('bg-red-500');
                connStatus.classList.add('animate-pulse'); // Start pulsing on disconnection
                connText.textContent = 'การเชื่อมต่อกับ Deribit ถูกตัด';
                connText.classList.remove('text-green-400', 'text-yellow-400');
                connText.classList.add('text-red-400');
                addLog('WebSocket การเชื่อมต่อกับ Deribit ถูกตัด. กำลังพยายามเชื่อมต่อใหม่...', 'warn');
                setTimeout(connectWebSocket, RECONNECT_INTERVAL); // Attempt to reconnect
            };

            ws.onerror = (error) => {
                addLog(`WebSocket ข้อผิดพลาด: ${error.message || 'ไม่ทราบข้อผิดพลาด'}`, 'warn');
                console.error("WebSocket Error:", error);
            };
        }

        /**
         * Handles incoming ticker updates from Deribit.
         * Updates the `instrumentData` map and triggers arbitrage calculation.
         * @param {Object} tickerData - The ticker data object.
         */
        function handleTickerUpdate(tickerData) {
            const instrumentName = tickerData.instrument_name;
            // Only update instrumentData and trigger calculations if bid_price and ask_price are present
            if (tickerData.bid_price !== undefined && tickerData.ask_price !== undefined) {
                instrumentData[instrumentName] = { 
                    mark_price: tickerData.mark_price, // Still keep mark_price for reference if needed
                    bid_price: tickerData.bid_price,
                    ask_price: tickerData.ask_price
                };
                // Trigger calculation and rendering only after initial scan is complete
                if (instrumentScanComplete) {
                    updateAndRenderOpportunities();
                }
            }
            // For BTC-PERPETUAL (used to get btcUsdPrice)
            if (instrumentName === 'BTC-PERPETUAL' && tickerData.index_price !== undefined) {
                btcUsdPrice = tickerData.index_price;
            }
        }


        // --- LLM MODAL FUNCTIONS ---
        /**
         * Displays the LLM modal with a title and content.
         * @param {string} title - The title for the modal.
         * @param {string} contentHtml - The HTML content to display in the modal body.
         */
        function showLlmModal(title, contentHtml = `<div class="flex items-center justify-center p-4"><div class="loading-spinner"></div><span class="ml-3 text-lg">กำลังสร้างคำตอบ...</span></div>`) {
            modalTitle.textContent = title;
            modalBody.innerHTML = contentHtml;
            llmModal.classList.add('show');
        }

        /**
         * Hides the LLM modal.
         */
        function hideLlmModal() {
            llmModal.classList.remove('show');
        }

        modalCloseBtn.addEventListener('click', hideLlmModal);

        // Fetch data from LLM
        async function fetchLlmResponse(prompt) {
            // Placeholder for API key, Canvas will provide it at runtime for default models
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            const payload = { contents: chatHistory };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error("LLM response structure unexpected:", result);
                    return "ไม่สามารถสร้างคำตอบได้ กรุณาลองใหม่ในภายหลัง.";
                }
            } catch (error) {
                console.error("Error fetching from LLM API:", error);
                return "เกิดข้อผิดพลาดในการเชื่อมต่อกับ LLM.";
            }
        }

        // LLM Explain Arbitrage Strategy button listener
        explainArbitrageBtn.addEventListener('click', async () => {
            showLlmModal('อธิบายกลยุทธ์ Arbitrage');
            let prompt = "อธิบายกลยุทธ์ Box Spread และ Calendar Spread ในตลาด Options สำหรับนักลงทุนรายย่อย. ให้รายละเอียดเกี่ยวกับวิธีการสร้าง spread, ผลตอบแทนที่คาดหวัง, และความเสี่ยงที่เกี่ยวข้อง อธิบายโดยใช้ภาษาไทยที่เข้าใจง่าย";
            
            // Add current arbitrage opportunities to the prompt if available, for context
            if (currentArbitrageType === 'box' && calculatedBoxSpreadsData.length > 0) {
                const topBox = calculatedBoxSpreadsData[0];
                prompt += `\n\nปัจจุบันมีโอกาส Box Spread ที่น่าสนใจที่สุด:
                - Expiry: ${topBox.expiry}
                - Strike Range: ${topBox.k1}-${topBox.k2}
                - Net Premium: $${topBox.netPremium.toFixed(2)} (คำนวณจากราคา Bid/Ask)
                - Theoretical Value: $${topBox.theoreticalValue.toFixed(2)}
                - Arbitrage Profit: $${topBox.arbitrageProfit.toFixed(2)}
                โปรดอธิบาย spread นี้โดยเฉพาะ และเน้นว่าราคาที่ใช้เป็นราคา Bid/Ask ที่สามารถเทรดได้จริง`;
            } else if (currentArbitrageType === 'calendar' && calculatedCalendarSpreadsData.length > 0) {
                const topCal = calculatedCalendarSpreadsData[0];
                prompt += `\n\nปัจจุบันมีโอกาส Calendar Spread ที่น่าสนใจที่สุด:
                - Type: ${topCal.type}
                - Strike: ${topCal.strike}
                - Shorter Expiry: ${topCal.shorterExpiry}
                - Longer Expiry: ${topCal.longerExpiry}
                - Premium Difference: $${topCal.premiumDiff.toFixed(2)} (คำนวณจากราคา Bid/Ask)
                - Arbitrage Profit: $${topCal.arbitrageProfit.toFixed(2)}
                โปรดอธิบาย spread นี้โดยเฉพาะ และเน้นว่าราคาที่ใช้เป็นราคา Bid/Ask ที่สามารถเทรดได้จริง`;
            }

            const response = await fetchLlmResponse(prompt);
            modalBody.innerHTML = `<p class="whitespace-pre-wrap">${response}</p>`; // Use pre-wrap for preserving formatting
        });

        // LLM Risk Assessment button listener
        riskAssessmentBtn.addEventListener('click', async () => {
            showLlmModal('ประเมินความเสี่ยง');
            let prompt = "ประเมินความเสี่ยงที่เกี่ยวข้องกับการทำ Arbitrage Options (โดยเฉพาะ Box Spread และ Calendar Spread) ในตลาด Crypto. ให้พิจารณาถึงความเสี่ยงจาก Liquidity, slippage, counterparty risk, และ regulatory changes.";

            // Add current arbitrage opportunities to the prompt for context
            if (currentArbitrageType === 'box' && calculatedBoxSpreadsData.length > 0) {
                const topBox = calculatedBoxSpreadsData[0];
                prompt += `\n\nพิจารณาความเสี่ยงที่เกี่ยวข้องกับ Box Spread นี้:
                - Expiry: ${topBox.expiry}
                - Strike Range: ${topBox.k1}-${topBox.k2}
                - Net Premium: $${topBox.netPremium.toFixed(2)} (คำนวณจากราคา Bid/Ask)
                - Theoretical Value: $${topBox.theoreticalValue.toFixed(2)}
                - Arbitrage Profit: $${topBox.arbitrageProfit.toFixed(2)}
                และอธิบายว่าข้อมูลเหล่านี้เกี่ยวข้องกับความเสี่ยงอย่างไร รวมถึงความเสี่ยงจาก Bid/Ask Spread ที่กว้างในตลาด Options`;
            } else if (currentArbitrageType === 'calendar' && calculatedCalendarSpreadsData.length > 0) {
                const topCal = calculatedCalendarSpreadsData[0];
                prompt += `\n\nพิจารณาความเสี่ยงที่เกี่ยวข้องกับ Calendar Spread นี้:
                - Type: ${topCal.type}
                - Strike: ${topCal.strike}
                - Shorter Expiry: ${topCal.shorterExpiry}
                - Longer Expiry: ${topCal.longerExpiry}
                - Premium Difference: $${topCal.premiumDiff.toFixed(2)} (คำนวณจากราคา Bid/Ask)
                - Arbitrage Profit: $${topCal.arbitrageProfit.toFixed(2)}
                และอธิบายว่าข้อมูลเหล่านี้เกี่ยวข้องกับความเสี่ยงอย่างไร รวมถึงความเสี่ยงจาก Bid/Ask Spread ที่กว้างในตลาด Options`;
            }

            const response = await fetchLlmResponse(prompt);
            modalBody.innerHTML = `<p class="whitespace-pre-wrap">${response}</p>`; // Use pre-wrap for preserving formatting
        });


        // --- INITIALIZATION ---
        loadSettings(); // Load settings from local storage
        connectWebSocket(); // Establish WebSocket connection on page load
    });
    </script>
</body>
</html>
