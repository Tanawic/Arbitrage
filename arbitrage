<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Crypto Options Arbitrage Scanner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the dark theme and specific elements */
        body {
            font-family: 'Sarabun', sans-serif;
            background-color: #111827; /* Dark background */
            color: #d1d5db; /* Light text */
        }
        .table-header {
            background-color: #374151; /* Darker gray for table header */
            color: #f9fafb; /* White text for header */
        }
        .positive-arbitrage {
            color: #4ade80; /* Green for positive arbitrage profit */
            font-weight: 700; /* Bold text */
        }
        .log-entry {
            border-left: 2px solid #4b5563; /* Gray border for log entries */
        }
        .log-success {
            border-left-color: #4ade80; /* Green border for success logs */
        }
        .log-warn {
            border-left-color: #facc15; /* Yellow border for warning/alert logs */
        }
        .tab-active {
            background-color: #4f46e5; /* Indigo for active tab */
            color: #fff; /* White text */
        }
        .tab-inactive {
            background-color: #374151; /* Dark gray for inactive tab */
            color: #d1d5db; /* Light text */
        }

        /* Keyframe animation for alert highlight */
        @keyframes pulse-bg {
            0%, 100% { background-color: #1e3a8a; } /* Dark blue */
            50% { background-color: #3b82f6; } /* Brighter blue */
        }
        .highlight-alert {
            animation: pulse-bg 1.5s infinite; /* Apply pulse animation */
        }

        /* Toast notification styles */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #2563eb; /* Blue background */
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Shadow effect */
            transform: translateX(120%); /* Start off-screen */
            transition: transform 0.5s ease-in-out; /* Smooth transition */
            z-index: 100; /* High z-index to be on top */
            opacity: 0; /* Initially hidden */
            pointer-events: none; /* Do not block interaction */
        }
        .toast.show {
            transform: translateX(0); /* Slide in */
            opacity: 1; /* Fade in */
            pointer-events: auto; /* Allow interaction */
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #1f2937;
            padding: 2rem;
            border-radius: 0.75rem;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #d1d5db;
            cursor: pointer;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-white">Dynamic Crypto Options Arbitrage Scanner</h1>
            <p class="text-indigo-400 mt-2">ค้นหา Box Spread และ Calendar Spread ที่มีกำไรสูงสุดอัตโนมัติ</p>
        </header>

        <!-- Controls & Settings Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div class="p-4 bg-gray-800 rounded-lg border border-gray-700 flex items-center justify-between">
                <div class="flex items-center space-x-2">
                    <!-- Connection status indicator -->
                    <div id="connection-status" class="w-4 h-4 rounded-full bg-yellow-500 animate-pulse"></div>
                    <span id="connection-text" class="text-yellow-400">กำลังเชื่อมต่อกับ Deribit...</span>
                </div>
                <!-- Last updated timestamp -->
                <div id="last-updated" class="text-sm text-gray-400">อัปเดตล่าสุด: -</div>
            </div>
            <div class="p-4 bg-gray-800 rounded-lg border border-gray-700">
                <h3 class="font-bold text-white mb-2">ตั้งค่าการแจ้งเตือนและการทำธุรกรรม</h3>
                <div class="flex flex-col space-y-3">
                    <div class="flex items-center space-x-3">
                        <label for="box-threshold" class="text-sm">แจ้งเตือนเมื่อกำไร > (USD):</label>
                        <!-- Input for arbitrage profit threshold -->
                        <input type="number" id="box-threshold" value="25" class="bg-gray-900 border border-gray-600 rounded-md p-1 w-24 text-center">
                        <!-- Mute/Unmute button for audio alerts -->
                        <button id="mute-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white text-xs font-bold py-1 px-3 rounded">ปิดเสียง</button>
                    </div>
                    <div class="flex items-center space-x-3">
                        <label for="transaction-fee" class="text-sm">ค่าธรรมเนียมการทำธุรกรรม (%):</label>
                        <!-- Input for transaction fee percentage -->
                        <input type="number" id="transaction-fee" value="0.03" step="0.01" class="bg-gray-900 border border-gray-600 rounded-md p-1 w-24 text-center">
                    </div>
                    <div class="flex items-center space-x-3 pt-2">
                        <!-- New: LLM-powered features -->
                        <button id="explain-arbitrage-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold py-2 px-4 rounded-md">✨ อธิบายกลยุทธ์</button>
                        <button id="risk-assessment-btn" class="bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold py-2 px-4 rounded-md">✨ ประเมินความเสี่ยง</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Arbitrage Type Tabs -->
        <div class="flex mb-4">
            <button id="tab-box-spread" class="tab-active py-2 px-4 rounded-l-lg font-semibold">Box Spread</button>
            <button id="tab-calendar-spread" class="tab-inactive py-2 px-4 rounded-r-lg font-semibold">Calendar Spread</button>
        </div>
        
        <!-- Box Spread Table -->
        <div id="box-spread-section" class="arb-section">
            <h2 class="text-xl font-bold text-white mb-3">Top 5 Box Spread Opportunities (BTC)</h2>
            <div class="overflow-x-auto bg-gray-800 rounded-lg shadow-md border border-gray-700">
                <table class="w-full text-sm text-left">
                    <thead class="table-header text-xs uppercase">
                        <tr>
                            <th class="px-4 py-3">Expiry</th>
                            <th class="px-4 py-3">Strike Range</th>
                            <th class="px-4 py-3">Net Premium (Mark Price USD)</th>
                            <th class="px-4 py-3">Theoretical Value (USD)</th>
                            <th class="px-4 py-3">Transaction Fees (USD)</th>
                            <th class="px-4 py-3">Arbitrage Profit (Net USD)</th>
                        </tr>
                    </thead>
                    <tbody id="box-table-body">
                        <tr id="box-loading-row"><td colspan="6" class="text-center p-8 text-gray-400">กำลังสแกนหา Options...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Calendar Spread Table -->
        <div id="calendar-spread-section" class="arb-section hidden">
            <h2 class="text-xl font-bold text-white mb-3">Top 5 Calendar Spread Opportunities (BTC)</h2>
            <div class="overflow-x-auto bg-gray-800 rounded-lg shadow-md border border-gray-700">
                <table class="w-full text-sm text-left">
                    <thead class="table-header text-xs uppercase">
                        <tr>
                            <th class="px-4 py-3">Type</th>
                            <th class="px-4 py-3">Strike</th>
                            <th class="px-4 py-3">Shorter Expiry</th>
                            <th class="px-4 py-3">Longer Expiry</th>
                            <th class="px-4 py-3">Premium Diff (Mark Price USD)</th>
                            <th class="px-4 py-3">Transaction Fees (USD)</th>
                            <th class="px-4 py-3">Arbitrage Profit (Net USD)</th>
                        </tr>
                    </thead>
                    <tbody id="calendar-table-body">
                        <tr id="calendar-loading-row"><td colspan="7" class="text-center p-8 text-gray-400">กำลังสแกนหา Options...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Execution Simulation Log Section -->
        <div class="mt-8">
            <h2 class="text-xl font-bold text-white mb-3">Execution & Alert Log</h2>
            <div id="log-container" class="bg-gray-900 rounded-lg p-4 h-48 overflow-y-auto border border-gray-700 space-y-3">
                <p class="text-gray-500">Log จะแสดงผลลัพธ์ที่นี่...</p>
            </div>
        </div>
    </div>
    
    <!-- Toast Notification Display -->
    <div id="toast-notification" class="toast"></div>

    <!-- LLM Response Modal -->
    <div id="llm-modal" class="modal">
        <div class="modal-content">
            <button id="modal-close-btn" class="modal-close-btn">&times;</button>
            <h3 id="modal-title" class="text-xl font-bold text-white mb-4"></h3>
            <div id="modal-body" class="text-gray-300">
                <div class="flex items-center justify-center p-4">
                    <div class="loading-spinner"></div>
                    <span class="ml-3 text-lg">กำลังสร้างคำตอบ...</span>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENTS ---
        const boxTableBody = document.getElementById('box-table-body');
        const calendarTableBody = document.getElementById('calendar-table-body');
        const logContainer = document.getElementById('log-container');
        const connStatus = document.getElementById('connection-status');
        const connText = document.getElementById('connection-text');
        const lastUpdatedEl = document.getElementById('last-updated');
        const boxThresholdInput = document.getElementById('box-threshold');
        const toastEl = document.getElementById('toast-notification');
        const muteBtn = document.getElementById('mute-btn');
        const boxLoadingRow = document.getElementById('box-loading-row');
        const calendarLoadingRow = document.getElementById('calendar-loading-row');
        const transactionFeeInput = document.getElementById('transaction-fee');

        // LLM-related DOM elements
        const explainArbitrageBtn = document.getElementById('explain-arbitrage-btn');
        const riskAssessmentBtn = document.getElementById('risk-assessment-btn');
        const llmModal = document.getElementById('llm-modal');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');

        // Arbitrage Type Tabs
        const tabBoxSpread = document.getElementById('tab-box-spread');
        const tabCalendarSpread = document.getElementById('tab-calendar-spread');
        const boxSpreadSection = document.getElementById('box-spread-section');
        const calendarSpreadSection = document.getElementById('calendar-spread-section');

        // --- STATE VARIABLES ---
        let ws = null; // WebSocket instance
        let audioCtx = null; // AudioContext for sound alerts
        let isMuted = false; // Mute state for audio alerts
        let instrumentData = {}; // Stores real-time bid/ask for subscribed instruments (key: instrument_name, value: ticker data)
        let potentialBoxSpreads = []; // Stores all possible box spread combinations
        let potentialCalendarSpreads = []; // Stores all possible calendar spread combinations
        let calculatedBoxSpreadsData = []; // Stores calculated box spreads for sorting and LLM context
        let calculatedCalendarSpreadsData = []; // Stores calculated calendar spreads for sorting and LLM context
        let alertedOpportunities = new Set(); // Stores IDs of opportunities that have triggered an alert
        let instrumentScanComplete = false; // Flag to indicate if initial instrument scan is done
        let currentArbitrageType = 'box'; // 'box' or 'calendar' - default to box spread

        let btcUsdPrice = 1; // Default BTC-USD price, will be updated by ticker data

        const RECONNECT_INTERVAL = 5000; // Time in ms to wait before attempting to reconnect WebSocket

        // --- AUDIO & VISUAL ALERTS ---
        /**
         * Initializes the Web Audio API context.
         * This needs to be called after a user gesture (e.g., a click)
         * to avoid browser autoplay policy restrictions.
         */
        function setupAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                addLog('Web Audio API พร้อมใช้งานสำหรับการแจ้งเตือน', 'info');
            } catch (e) {
                console.warn('Web Audio API is not supported in this browser.', e);
                addLog('ไม่รองรับ Web Audio API ในเบราว์เซอร์นี้. การแจ้งเตือนด้วยเสียงจะถูกปิดใช้งาน', 'warn');
            }
        }

        /**
         * Plays a short, softer triangle wave sound alert.
         */
        function playAlertSound() {
            if (!audioCtx || isMuted) return; // Don't play if audio context not ready or muted

            // Ensure audio context is not suspended
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'triangle'; // Changed to triangle for a softer sound
            oscillator.frequency.setValueAtTime(660, audioCtx.currentTime); // Lowered frequency for a mellower tone (was 880)
            gainNode.gain.setValueAtTime(0.01, audioCtx.currentTime); // Start quietly
            gainNode.gain.exponentialRampToValueAtTime(0.3, audioCtx.currentTime + 0.1); // Ramp up to 0.3 volume
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6); // Fade out over 0.6 seconds

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.6); // Stop after 0.6 seconds
        }

        /**
         * Displays a temporary toast notification at the bottom right.
         * @param {string} message - The message to display in the toast.
         */
        function showToast(message) {
            toastEl.textContent = message;
            toastEl.classList.add('show'); // Add 'show' class to trigger CSS transition
            setTimeout(() => {
                toastEl.classList.remove('show'); // Remove 'show' class to hide after delay
            }, 4000); // Display for 4 seconds
        }

        // Mute/Unmute button functionality
        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted; // Toggle mute state
            // Update button text and style based on mute state
            muteBtn.textContent = isMuted ? 'เปิดเสียง' : 'ปิดเสียง';
            muteBtn.classList.toggle('bg-yellow-600', !isMuted); // Yellow when unmuted
            muteBtn.classList.toggle('hover:bg-yellow-700', !isMuted);
            muteBtn.classList.toggle('bg-green-600', isMuted); // Green when muted
            muteBtn.classList.toggle('hover:bg-green-700', isMuted);
            addLog(`การแจ้งเตือนด้วยเสียงถูก ${isMuted ? 'ปิดเสียง' : 'เปิดเสียง'}`, 'info');
        });

        // Event listener to setup audio context on first user interaction
        document.body.addEventListener('click', () => {
            if (!audioCtx) setupAudio(); // Initialize audio context only once on user interaction
        }, { once: true });

        // --- LOGGING ---
        /**
         * Adds a new entry to the log container.
         * @param {string} message - The message to log.
         * @param {string} type - Type of log ('info', 'success', 'warn'). Affects styling.
         */
        function addLog(message, type = 'info') {
            // Remove initial placeholder message if present
            if (logContainer.querySelector('p.text-gray-500')) {
                logContainer.innerHTML = '';
            }
            const logEntry = document.createElement('div');
            // Apply Tailwind classes for styling based on log type
            logEntry.className = `log-entry p-2 text-sm rounded-md ${type === 'success' ? 'log-success bg-green-900/50' : type === 'warn' ? 'log-warn bg-yellow-900/50' : 'bg-gray-700/50'}`;
            logEntry.innerHTML = `<span class="font-mono text-gray-400">[${new Date().toLocaleTimeString()}]</span> ${message}`;
            logContainer.prepend(logEntry); // Add new log entry to the top
            // Limit log entries to 50 to prevent excessive DOM elements
            if (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // --- LOCAL STORAGE FOR THRESHOLD & FEES ---
        /**
         * Loads settings from local storage or uses defaults.
         */
        function loadSettings() {
            const storedThreshold = localStorage.getItem('boxArbitrageThreshold');
            if (storedThreshold !== null) {
                boxThresholdInput.value = storedThreshold;
                addLog(`โหลดค่าเกณฑ์การแจ้งเตือนจาก Local Storage: $${storedThreshold}`, 'info');
            }

            const storedFee = localStorage.getItem('boxArbitrageFee');
            if (storedFee !== null) {
                transactionFeeInput.value = storedFee;
                addLog(`โหลดค่าธรรมเนียมการทำธุรกรรมจาก Local Storage: ${storedFee}%`, 'info');
            }

            const storedArbType = localStorage.getItem('currentArbitrageType');
            if (storedArbType) {
                currentArbitrageType = storedArbType;
                // Set active tab based on loaded type
                if (currentArbitrageType === 'box') {
                    showBoxSpreadSection();
                } else {
                    showCalendarSpreadSection();
                }
            } else {
                // Default to box spread if no setting found
                showBoxSpreadSection();
            }
        }

        /**
         * Saves the current settings to local storage.
         */
        function saveSettings() {
            localStorage.setItem('boxArbitrageThreshold', boxThresholdInput.value);
            localStorage.setItem('boxArbitrageFee', transactionFeeInput.value);
            localStorage.setItem('currentArbitrageType', currentArbitrageType);
            addLog(`บันทึกการตั้งค่าทั้งหมดแล้ว`, 'info');
        }

        // Add event listeners to save settings on input change
        boxThresholdInput.addEventListener('change', saveSettings);
        transactionFeeInput.addEventListener('change', saveSettings);

        // --- ARBITRAGE TYPE TAB SWITCHING ---
        function showBoxSpreadSection() {
            boxSpreadSection.classList.remove('hidden');
            calendarSpreadSection.classList.add('hidden');
            tabBoxSpread.classList.add('tab-active');
            tabBoxSpread.classList.remove('tab-inactive');
            tabCalendarSpread.classList.remove('tab-active');
            tabCalendarSpread.classList.add('tab-inactive');
            currentArbitrageType = 'box';
            saveSettings(); // Save current tab preference
            updateAndRenderOpportunities(); // Re-render for the active tab
        }

        function showCalendarSpreadSection() {
            boxSpreadSection.classList.add('hidden');
            calendarSpreadSection.classList.remove('hidden');
            tabCalendarSpread.classList.add('tab-active');
            tabCalendarSpread.classList.remove('tab-inactive');
            tabBoxSpread.classList.remove('tab-active');
            tabBoxSpread.classList.add('tab-inactive');
            currentArbitrageType = 'calendar';
            saveSettings(); // Save current tab preference
            updateAndRenderOpportunities(); // Re-render for the active tab
        }

        tabBoxSpread.addEventListener('click', showBoxSpreadSection);
        tabCalendarSpread.addEventListener('click', showCalendarSpreadSection);


        // --- DYNAMIC INSTRUMENT DISCOVERY & ARBITRAGE CALCULATION ---
        // Global map to store options structured for Calendar Spreads: strike -> expiry -> type (C/P) -> instrument_name
        let calendarOptionsMap = {};
        // Global map to store options structured for Box Spreads: expiry -> strike -> type (C/P) -> instrument_name
        let boxOptionsMap = {};

        /**
         * Processes the list of instruments received from Deribit,
         * filters for BTC options, and populates both boxOptionsMap and calendarOptionsMap.
         * @param {Array<Object>} instruments - Array of instrument objects from Deribit API.
         */
        function processInstruments(instruments) {
            addLog('ประมวลผล Options ที่ได้รับจาก Deribit...', 'info');
            
            boxOptionsMap = {}; // Reset for Box Spreads
            calendarOptionsMap = {}; // Reset for Calendar Spreads

            instruments
                .filter(inst => inst.instrument_name.startsWith('BTC-') && inst.kind === 'option' && !inst.expired)
                .forEach(inst => {
                    const parts = inst.instrument_name.split('-');
                    const expiry = parts[1]; // e.g., '29JUN25'
                    const strike = parseInt(parts[2]); // e.g., 70000
                    const type = parts[3]; // 'C' for Call, 'P' for Put

                    // Populate boxOptionsMap (expiry -> strike -> type)
                    if (!boxOptionsMap[expiry]) {
                        boxOptionsMap[expiry] = {};
                    }
                    if (!boxOptionsMap[expiry][strike]) {
                        boxOptionsMap[expiry][strike] = {};
                    }
                    boxOptionsMap[expiry][strike][type] = inst.instrument_name;

                    // Populate calendarOptionsMap (strike -> expiry -> type)
                    if (!calendarOptionsMap[strike]) {
                        calendarOptionsMap[strike] = {};
                    }
                    if (!calendarOptionsMap[strike][expiry]) {
                        calendarOptionsMap[strike][expiry] = {};
                    }
                    calendarOptionsMap[strike][expiry][type] = inst.instrument_name;
                });
            
            createPotentialBoxSpreads();
            createPotentialCalendarSpreads();

            addLog(`สร้าง Box Spread ที่เป็นไปได้ทั้งหมด ${potentialBoxSpreads.length} ชุดสำหรับ BTC`, 'success');
            addLog(`สร้าง Calendar Spread ที่เป็นไปได้ทั้งหมด ${potentialCalendarSpreads.length} ชุดสำหรับ BTC`, 'success');
            
            instrumentScanComplete = true; // Mark initial scan as complete

            // 3. Subscribe to real-time tickers for all identified legs from both strategies
            const allBoxLegs = potentialBoxSpreads.flatMap(box => box.legs);
            const allCalendarLegs = potentialCalendarSpreads.flatMap(cal => cal.legs);
            const allUniqueLegs = new Set([...allBoxLegs, ...allCalendarLegs]); // Combine and get unique

            addLog(`กำลังติดตามราคา ${allUniqueLegs.size} instruments...`, 'info');
            
            // Subscribe in batches to avoid large single WebSocket messages
            const channels = Array.from(allUniqueLegs).map(leg => `ticker.${leg}.100ms`); // Create ticker channel string
            const batchSize = 100; // Max instruments per subscribe request
            for (let i = 0; i < channels.length; i += batchSize) {
                const batch = channels.slice(i, i + batchSize);
                ws.send(JSON.stringify({
                    "jsonrpc": "2.0",
                    "method": "public/subscribe",
                    "id": `sub-${i / batchSize}`, // Unique ID for each subscription batch
                    "params": { "channels": batch }
                }));
            }
        }

        /**
         * Creates all potential Box Spread combinations from `boxOptionsMap`.
         */
        function createPotentialBoxSpreads() {
            potentialBoxSpreads = [];
            for (const expiry in boxOptionsMap) {
                const strikes = Object.keys(boxOptionsMap[expiry]).map(Number).sort((a, b) => a - b);
                for (let i = 0; i < strikes.length; i++) {
                    for (let j = i + 1; j < strikes.length; j++) {
                        const k1 = strikes[i]; // Lower strike
                        const k2 = strikes[j]; // Higher strike
                        
                        const leg1 = boxOptionsMap[expiry][k1]?.C; // Buy Call K1
                        const leg2 = boxOptionsMap[expiry][k1]?.P; // Sell Put K1
                        const leg3 = boxOptionsMap[expiry][k2]?.C; // Sell Call K2
                        const leg4 = boxOptionsMap[expiry][k2]?.P; // Buy Put K2
                        
                        if (leg1 && leg2 && leg3 && leg4) {
                            potentialBoxSpreads.push({
                                id: `BOX-${expiry}-${k1}-${k2}`,
                                expiry: expiry,
                                k1: k1,
                                k2: k2,
                                legs: [leg1, leg2, leg3, leg4]
                            });
                        }
                    }
                }
            }
        }

        /**
         * Creates all potential Calendar Spread combinations from `calendarOptionsMap`.
         */
        function createPotentialCalendarSpreads() {
            potentialCalendarSpreads = [];
            for (const strike in calendarOptionsMap) {
                const expiries = Object.keys(calendarOptionsMap[strike]).sort(); // Sort expiries to ensure short before long
                for (let i = 0; i < expiries.length; i++) {
                    for (let j = i + 1; j < expiries.length; j++) {
                        const shorterExpiry = expiries[i];
                        const longerExpiry = expiries[j];

                        // Check for Call Calendar Spread (Sell Shorter Call, Buy Longer Call)
                        const shorterCall = calendarOptionsMap[strike][shorterExpiry]?.C;
                        const longerCall = calendarOptionsMap[strike][longerExpiry]?.C;
                        if (shorterCall && longerCall) {
                            potentialCalendarSpreads.push({
                                id: `CAL-${strike}-C-${shorterExpiry}-${longerExpiry}`,
                                type: 'CALL', // Type of option (Call/Put)
                                strike: parseInt(strike),
                                shorterExpiry: shorterExpiry,
                                longerExpiry: longerExpiry,
                                legs: [shorterCall, longerCall] // [Shorter Option, Longer Option]
                            });
                        }

                        // Check for Put Calendar Spread (Sell Shorter Put, Buy Longer Put)
                        const shorterPut = calendarOptionsMap[strike][shorterExpiry]?.P;
                        const longerPut = calendarOptionsMap[strike][longerExpiry]?.P;
                        if (shorterPut && longerPut) {
                            potentialCalendarSpreads.push({
                                id: `CAL-${strike}-P-${shorterExpiry}-${longerExpiry}`,
                                type: 'PUT', // Type of option (Call/Put)
                                strike: parseInt(strike),
                                shorterExpiry: shorterExpiry,
                                longerExpiry: longerExpiry,
                                legs: [shorterPut, longerPut] // [Shorter Option, Longer Option]
                            });
                        }
                    }
                }
            }
        }
        
        /**
         * Calculates and renders opportunities based on the current arbitrage type.
         */
        function updateAndRenderOpportunities() {
            if (!instrumentScanComplete) return;

            const threshold = parseFloat(boxThresholdInput.value) || 0;
            const transactionFeeRate = parseFloat(transactionFeeInput.value) / 100 || 0;
            
            // Create a copy of alerted opportunities to track which ones become unprofitable
            const previouslyAlerted = new Set(alertedOpportunities);
            alertedOpportunities.clear(); // Clear for current update cycle, re-add if still profitable

            if (currentArbitrageType === 'box') {
                calculatedBoxSpreadsData = [];
                potentialBoxSpreads.forEach(box => {
                    const legData = box.legs.map(leg => instrumentData[leg]);
                    // Ensure all legs have mark_price for calculation
                    if (legData.some(d => !d || d.mark_price === undefined)) {
                        return;
                    }

                    // Convert premiums from BTC (mark_price) to USD
                    const leg1PremiumUSD = legData[0].mark_price * btcUsdPrice; // Buy Call K1
                    const leg2PremiumUSD = legData[1].mark_price * btcUsdPrice; // Sell Put K1
                    const leg3PremiumUSD = legData[2].mark_price * btcUsdPrice; // Sell Call K2
                    const leg4PremiumUSD = legData[3].mark_price * btcUsdPrice; // Buy Put K2

                    // Box Spread: Buy Call K1, Sell Put K1, Sell Call K2, Buy Put K2
                    // Gross Net Premium (USD) = (Premium C_K1 in USD) - (Premium P_K1 in USD) - (Premium C_K2 in USD) + (Premium P_K2 in USD)
                    // Note: Using mark_price for all premiums for consistency as per user's request,
                    // which differs from traditional bid/ask based arbitrage.
                    const grossNetPremiumUSD = leg1PremiumUSD - leg2PremiumUSD - leg3PremiumUSD + leg4PremiumUSD;
                    
                    // Theoretical value (strike difference) is already in USD
                    const theoreticalValueUSD = (box.k2 - box.k1); 
                    
                    // Fees are sum of (premium * fee_rate) for each leg, already in USD
                    const totalTransactionFees = (leg1PremiumUSD * transactionFeeRate) +
                                                 (leg2PremiumUSD * transactionFeeRate) +
                                                 (leg3PremiumUSD * transactionFeeRate) +
                                                 (leg4PremiumUSD * transactionFeeRate);

                    const profit = theoreticalValueUSD - grossNetPremiumUSD - totalTransactionFees;
                    
                    box.profit = profit;
                    box.grossNetPremium = grossNetPremiumUSD; // Store in USD
                    box.theoreticalValue = theoreticalValueUSD; // Store in USD
                    box.totalTransactionFees = totalTransactionFees;
                    calculatedBoxSpreadsData.push(box);

                    const isProfitable = profit >= threshold;
                    if (isProfitable) {
                        alertedOpportunities.add(box.id); // Still profitable, keep in alerted set
                        if (!previouslyAlerted.has(box.id)) { // Only alert if new or re-profitable
                            playAlertSound();
                            showToast(`พบ Box Spread Arbitrage! กำไรสุทธิ: $${profit.toFixed(2)}`);
                            addLog(`🚨 <span class="text-yellow-300">แจ้งเตือน [${box.expiry} ${box.k1}/${box.k2}]!</span> กำไรสุทธิ: <span class="font-bold text-green-400">$${profit.toFixed(2)}</span>`, 'warn');
                        }
                    } else if (previouslyAlerted.has(box.id)) {
                        // Was profitable but no longer, remove from alerted set implicitly by not re-adding
                        // and optionally log if needed
                        addLog(`Box Spread [${box.expiry} ${box.k1}/${box.k2}] กำไรต่ำกว่าเกณฑ์ (${profit.toFixed(2)} USD)`, 'info');
                    }
                });

                const top5 = calculatedBoxSpreadsData.sort((a, b) => b.profit - a.profit).slice(0, 5);
                boxTableBody.innerHTML = '';
                if (top5.length === 0) {
                    boxLoadingRow.querySelector('td').textContent = instrumentScanComplete ? "กำลังรอข้อมูลราคา Real-time หรือไม่พบโอกาส Arbitrage." : "กำลังสแกนหา Options...";
                    boxTableBody.appendChild(boxLoadingRow);
                } else {
                    top5.forEach(box => {
                        const row = document.createElement('tr');
                        row.className = `bg-gray-800 border-b border-gray-700 transition-colors duration-500 ${alertedOpportunities.has(box.id) ? 'highlight-alert' : ''}`;
                        row.innerHTML = `
                            <td class="px-4 py-3 font-medium text-white">${box.expiry}</td>
                            <td class="px-4 py-3">${box.k1} / ${box.k2}</td>
                            <td class="px-4 py-3 text-center">${box.grossNetPremium.toFixed(2)}</td>
                            <td class="px-4 py-3 text-center">${box.theoreticalValue.toFixed(2)}</td>
                            <td class="px-4 py-3 text-center">${box.totalTransactionFees.toFixed(2)}</td>
                            <td class="px-4 py-3 text-center positive-arbitrage">${box.profit.toFixed(2)}</td>
                        `;
                        boxTableBody.appendChild(row);
                    });
                }
            } else if (currentArbitrageType === 'calendar') {
                calculatedCalendarSpreadsData = [];
                potentialCalendarSpreads.forEach(cal => {
                    // legs: [Shorter Option, Longer Option]
                    const shorterLegData = instrumentData[cal.legs[0]];
                    const longerLegData = instrumentData[cal.legs[1]];

                    // Ensure both legs have mark_price for calculation
                    if (!shorterLegData || !longerLegData || 
                        shorterLegData.mark_price === undefined || longerLegData.mark_price === undefined) {
                        return;
                    }

                    // Calendar Spread: Sell Shorter, Buy Longer (same strike, different expiries)
                    // premium_2 (shorter, sold) = shorterLegData.mark_price (in BTC)
                    // premium_1 (longer, bought) = longerLegData.mark_price (in BTC)
                    
                    // Convert premiums from BTC (mark_price) to USD
                    const premiumShorterSoldUSD = shorterLegData.mark_price * btcUsdPrice;
                    const premiumLongerBoughtUSD = longerLegData.mark_price * btcUsdPrice;

                    // Gross Profit / Premium Difference (USD) (before fees)
                    const grossPremiumDifferenceUSD = premiumShorterSoldUSD - premiumLongerBoughtUSD;
                    
                    // Fees: Fee_shorter (on selling shorter) + Fee_longer (on buying longer), already in USD
                    const totalTransactionFees = (premiumShorterSoldUSD * transactionFeeRate) +
                                                 (premiumLongerBoughtUSD * transactionFeeRate);

                    // Net Profit = Gross Premium Difference - Total Transaction Fees
                    const profit = grossPremiumDifferenceUSD - totalTransactionFees;

                    cal.profit = profit;
                    cal.grossPremiumDifference = grossPremiumDifferenceUSD; // Store in USD
                    cal.totalTransactionFees = totalTransactionFees;
                    calculatedCalendarSpreadsData.push(cal);

                    const isProfitable = profit >= threshold;
                    if (isProfitable) {
                        alertedOpportunities.add(cal.id); // Still profitable, keep in alerted set
                        if (!previouslyAlerted.has(cal.id)) { // Only alert if new or re-profitable
                            playAlertSound();
                            showToast(`พบ Calendar Spread Arbitrage! กำไรสุทธิ: $${profit.toFixed(2)}`);
                            addLog(`🚨 <span class="text-yellow-300">แจ้งเตือน [CAL ${cal.strike} ${cal.type} ${cal.shorterExpiry}/${cal.longerExpiry}]!</span> กำไรสุทธิ: <span class="font-bold text-green-400">$${profit.toFixed(2)}</span>`, 'warn');
                        }
                    } else if (previouslyAlerted.has(cal.id)) {
                        // Was profitable but no longer, remove from alerted set implicitly by not re-adding
                        // and optionally log if needed
                        addLog(`Calendar Spread [${cal.strike} ${cal.type} ${cal.shorterExpiry}/${cal.longerExpiry}] กำไรต่ำกว่าเกณฑ์ (${profit.toFixed(2)} USD)`, 'info');
                    }
                });

                const top5 = calculatedCalendarSpreadsData.sort((a, b) => b.profit - a.profit).slice(0, 5); 
                calendarTableBody.innerHTML = '';
                if (top5.length === 0) {
                    calendarLoadingRow.querySelector('td').textContent = instrumentScanComplete ? "กำลังรอข้อมูลราคา Real-time หรือไม่พบโอกาส Arbitrage." : "กำลังสแกนหา Options...";
                    calendarTableBody.appendChild(calendarLoadingRow);
                } else {
                    top5.forEach(cal => {
                        const row = document.createElement('tr');
                        row.className = `bg-gray-800 border-b border-gray-700 transition-colors duration-500 ${alertedOpportunities.has(cal.id) ? 'highlight-alert' : ''}`;
                        row.innerHTML = `
                            <td class="px-4 py-3 font-medium text-white">${cal.type}</td>
                            <td class="px-4 py-3">${cal.strike}</td>
                            <td class="px-4 py-3">${cal.shorterExpiry}</td>
                            <td class="px-4 py-3">${cal.longerExpiry}</td>
                            <td class="px-4 py-3 text-center">${cal.grossPremiumDifference.toFixed(2)}</td>
                            <td class="px-4 py-3 text-center">${cal.totalTransactionFees.toFixed(2)}</td>
                            <td class="px-4 py-3 text-center positive-arbitrage">${cal.profit.toFixed(2)}</td>
                        `;
                        calendarTableBody.appendChild(row);
                    });
                }
            }
            lastUpdatedEl.textContent = `อัปเดตล่าสุด: ${new Date().toLocaleTimeString('th-TH')}`;
        }
        
        // --- WEBSOCKET CONNECTION ---
        /**
         * Establishes a WebSocket connection to Deribit.
         * Includes logic for connection status, message handling, and reconnection.
         */
        function connectWebSocket() {
            // If a WebSocket connection already exists, close it first
            if (ws) {
                ws.close();
            }

            connStatus.classList.replace('bg-green-500', 'bg-yellow-500');
            connStatus.classList.replace('bg-red-500', 'bg-yellow-500');
            connStatus.classList.add('animate-pulse'); // Pulsing yellow indicates connecting
            connText.textContent = 'กำลังเชื่อมต่อกับ Deribit...';
            connText.classList.replace('text-green-400', 'text-yellow-400');
            connText.classList.replace('text-red-400', 'text-yellow-400');
            addLog('กำลังพยายามเชื่อมต่อกับ Deribit...', 'info');

            ws = new WebSocket('wss://www.deribit.com/ws/api/v2');

            ws.onopen = () => {
                connStatus.classList.remove('animate-pulse');
                connStatus.classList.replace('bg-yellow-500', 'bg-green-500');
                connText.textContent = 'เชื่อมต่อสำเร็จ';
                connText.classList.replace('text-yellow-400', 'text-green-400');
                addLog('เชื่อมต่อกับ Deribit สำเร็จ. กำลังดึงรายการ Options...', 'success');

                // Request all BTC options after successful connection
                ws.send(JSON.stringify({
                    "jsonrpc": "2.0",
                    "method": "public/get_instruments",
                    "id": 101, // Request ID for get_instruments
                    "params": { "currency": "BTC", "kind": "option", "expired": false }
                }));
                // Subscribe to BTC-PERPETUAL for index_price to convert BTC premiums to USD
                ws.send(JSON.stringify({
                    "jsonrpc": "2.0",
                    "method": "public/subscribe",
                    "id": 102,
                    "params": { "channels": ["ticker.BTC-PERPETUAL.100ms"] }
                }));
            };

            ws.onmessage = (event) => {
                const response = JSON.parse(event.data);
                
                // Handle response for the initial get_instruments request
                if (response.id === 101 && response.result) {
                    processInstruments(response.result);
                }
                
                // Handle real-time ticker data subscriptions
                if (response.method === 'subscription' && response.params.channel.startsWith('ticker')) {
                    const data = response.params.data;
                    instrumentData[data.instrument_name] = data;
                    // Update BTC-USD price from BTC-PERPETUAL ticker's index_price
                    if (data.instrument_name === 'BTC-PERPETUAL' && data.index_price !== undefined) {
                        btcUsdPrice = data.index_price;
                    }
                }

                // Handle heartbeat responses to keep the connection alive
                if (response.method === 'heartbeat') {
                    // Respond to heartbeat to acknowledge and keep session alive
                    ws.send(JSON.stringify({"jsonrpc": "2.0", "method": "public/test", "id": 999}));
                }
            };

            ws.onclose = (event) => {
                connStatus.classList.remove('animate-pulse');
                connStatus.classList.replace('bg-green-500', 'bg-red-500');
                connStatus.classList.replace('bg-yellow-500', 'bg-red-500');
                connText.textContent = 'การเชื่อมต่อถูกตัด';
                connText.classList.replace('text-green-400', 'text-red-400');
                connText.classList.replace('text-yellow-400', 'text-red-400');
                addLog(`การเชื่อมต่อกับ Deribit ถูกตัด: โค้ด ${event.code}, เหตุผล: ${event.reason || 'ไม่ทราบ'}`, 'warn');
                instrumentScanComplete = false; // Reset flag so it rescans instruments on reconnect
                setTimeout(connectWebSocket, RECONNECT_INTERVAL); // Attempt to reconnect after a delay
            };

            ws.onerror = (error) => {
                connStatus.classList.remove('animate-pulse');
                connStatus.classList.replace('bg-green-500', 'bg-red-500');
                connStatus.classList.replace('bg-yellow-500', 'bg-red-500');
                connText.textContent = 'เกิดข้อผิดพลาดในการเชื่อมต่อ';
                connText.classList.replace('text-green-400', 'text-red-400');
                connText.classList.replace('text-yellow-400', 'text-red-400');
                addLog(`เกิดข้อผิดพลาด WebSocket: ${error.message || 'ไม่ทราบสาเหตุ'}`, 'warn');
                ws.close(); // Close the problematic connection to trigger onclose and retry
            };
        }

        // --- LLM (Gemini API) Integration ---
        /**
         * Calls the Gemini API to generate text based on a given prompt.
         * Displays a loading spinner and then the response in a modal.
         * @param {string} title - Title for the modal.
         * @param {string} prompt - The prompt to send to the LLM.
         */
        async function callGeminiAPI(title, prompt) {
            modalTitle.textContent = title;
            modalBody.innerHTML = `
                <div class="flex items-center justify-center p-4">
                    <div class="loading-spinner"></div>
                    <span class="ml-3 text-lg">กำลังสร้างคำตอบ...</span>
                </div>
            `;
            llmModal.classList.add('show');

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // Canvas will automatically provide the API key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    modalBody.innerHTML = `<p class="whitespace-pre-wrap">${text}</p>`; // Use pre-wrap to preserve formatting
                    addLog(`ได้รับคำตอบจาก Gemini API สำหรับ: "${title}"`, 'success');
                } else {
                    modalBody.innerHTML = `<p class="text-red-400">ไม่สามารถสร้างคำตอบได้. โปรดลองอีกครั้ง.</p>`;
                    addLog(`ข้อผิดพลาด: ไม่สามารถรับคำตอบที่ถูกต้องจาก Gemini API สำหรับ: "${title}"`, 'warn');
                    console.error("Gemini API response structure unexpected:", result);
                }
            } catch (error) {
                modalBody.innerHTML = `<p class="text-red-400">เกิดข้อผิดพลาดในการเรียกใช้ Gemini API: ${error.message}</p>`;
                addLog(`ข้อผิดพลาดในการเรียกใช้ Gemini API สำหรับ: "${title}" - ${error.message}`, 'warn');
                console.error("Error calling Gemini API:", error);
            }
        }

        // Event listener for "Explain Arbitrage" button
        explainArbitrageBtn.addEventListener('click', () => {
            let prompt = "";
            let title = "";
            if (currentArbitrageType === 'box') {
                title = "คำอธิบาย Box Spread Arbitrage";
                prompt = "อธิบาย Box Spread arbitrage ในตลาด crypto options โดยใช้ภาษาที่เข้าใจง่ายและเป็นภาษาไทย";
            } else {
                title = "คำอธิบาย Calendar Spread Arbitrage";
                prompt = "อธิบาย Calendar Spread arbitrage ในตลาด crypto options โดยใช้ภาษาที่เข้าใจง่ายและเป็นภาษาไทย";
            }
            callGeminiAPI(title, prompt);
        });

        // Event listener for "Risk Assessment" button
        riskAssessmentBtn.addEventListener('click', () => {
            let prompt = "";
            let title = "";
            let opportunitiesData = (currentArbitrageType === 'box' ? calculatedBoxSpreadsData : calculatedCalendarSpreadsData);

            if (opportunitiesData.length === 0 || opportunitiesData[0].profit <= 0) {
                title = `การประเมินความเสี่ยงทั่วไปสำหรับ ${currentArbitrageType === 'box' ? 'Box Spread' : 'Calendar Spread'}`;
                prompt = `โปรดอธิบายความเสี่ยงทั่วไปที่อาจเกิดขึ้นกับกลยุทธ์ ${currentArbitrageType === 'box' ? 'Box Spread' : 'Calendar Spread'} arbitrage ในตลาด crypto options โดยละเอียดและเป็นภาษาไทย`;
                addLog(`ไม่มีโอกาส Arbitrage ที่มีกำไรในปัจจุบันสำหรับ ${currentArbitrageType === 'box' ? 'Box Spread' : 'Calendar Spread'}, ให้คำแนะนำความเสี่ยงทั่วไปแทน.`, 'info');
            } else {
                const topOpportunity = opportunitiesData[0]; // Get the top profitable opportunity
                if (currentArbitrageType === 'box') {
                    title = `การประเมินความเสี่ยงสำหรับ Box Spread: ${topOpportunity.expiry} ${topOpportunity.k1}/${topOpportunity.k2}`;
                    prompt = `สำหรับ Box Spread arbitrage ใน crypto options ที่มีวันหมดอายุ ${topOpportunity.expiry}, Strike K1 ที่ ${topOpportunity.k1} และ Strike K2 ที่ ${topOpportunity.k2} และมีกำไรสุทธิ ${topOpportunity.profit.toFixed(2)} USD โปรดอธิบายความเสี่ยงที่อาจเกิดขึ้นกับกลยุทธ์นี้โดยละเอียดและเป็นภาษาไทย`;
                } else {
                    title = `การประเมินความเสี่ยงสำหรับ Calendar Spread: ${topOpportunity.strike} ${topOpportunity.type}, วันหมดอายุระยะสั้น ${topOpportunity.shorterExpiry} และระยะยาว ${topOpportunity.longerExpiry} และมีกำไรสุทธิ ${topOpportunity.profit.toFixed(2)} USD โปรดอธิบายความเสี่ยงที่อาจเกิดขึ้นกับกลยุทธ์นี้โดยละเอียดและเป็นภาษาไทย`;
                }
            }
            callGeminiAPI(title, prompt);
        });

        // Close modal functionality
        modalCloseBtn.addEventListener('click', () => {
            llmModal.classList.remove('show');
            modalBody.innerHTML = ''; // Clear content when closing
        });

        // Close modal when clicking outside of the content
        llmModal.addEventListener('click', (e) => {
            if (e.target === llmModal) {
                llmModal.classList.remove('show');
                modalBody.innerHTML = '';
            }
        });

        // --- INITIALIZATION ---
        loadSettings(); // Load all settings (threshold and fee) from local storage on startup
        connectWebSocket(); // Initiate WebSocket connection
        // Set an interval to re-calculate and re-render the top list periodically
        setInterval(updateAndRenderOpportunities, 1000); // Update table and check alerts every second
    });
    </script>
</body>
</html>
